Help on module pyparsing:

NAME
    pyparsing - pyparsing module - Classes and methods to define and execute parsing grammars

DESCRIPTION
    The pyparsing module is an alternative approach to creating and executing simple grammars,
    vs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you
    don't need to learn a new syntax for defining grammars or matching expressions - the parsing module
    provides a library of classes that you use to construct the grammar directly in Python.
    
    Here is a program to parse "Hello, World!" (or any greeting of the form 
    C{"<salutation>, <addressee>!"}), built up using L{Word}, L{Literal}, and L{And} elements 
    (L{'+'<ParserElement.__add__>} operator gives L{And} expressions, strings are auto-converted to
    L{Literal} expressions)::
    
        from pyparsing import Word, alphas
    
        # define grammar of a greeting
        greet = Word(alphas) + "," + Word(alphas) + "!"
    
        hello = "Hello, World!"
        print (hello, "->", greet.parseString(hello))
    
    The program outputs the following::
    
        Hello, World! -> ['Hello', ',', 'World', '!']
    
    The Python representation of the grammar is quite readable, owing to the self-explanatory
    class names, and the use of '+', '|' and '^' operators.
    
    The L{ParseResults} object returned from L{ParserElement.parseString<ParserElement.parseString>} can be accessed as a nested list, a dictionary, or an
    object with named attributes.
    
    The pyparsing module handles some of the problems that are typically vexing when writing text parsers:
     - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)
     - quoted strings
     - embedded comments

CLASSES
    builtins.Exception(builtins.BaseException)
        ParseBaseException
            ParseException
            ParseFatalException
                ParseSyntaxException
        RecursiveGrammarException
    builtins.object
        OnlyOnce
        ParseResults
        ParserElement
            ParseElementEnhance
                FollowedBy
                Forward
                NotAny
                Optional
                SkipTo
                TokenConverter
                    Combine
                    Dict
                    Group
                    Suppress
            ParseExpression
                And
                Each
                MatchFirst
                Or
            Token
                CharsNotIn
                CloseMatch
                Empty
                Keyword
                    CaselessKeyword
                Literal
                    CaselessLiteral
                NoMatch
                QuotedString
                Regex
                White
                Word
        pyparsing_common
    _MultipleMatch(ParseElementEnhance)
        OneOrMore
        ZeroOrMore
    _PositionToken(Token)
        GoToColumn
        LineEnd
        LineStart
        StringEnd
        StringStart
        WordEnd
        WordStart
    
    class And(ParseExpression)
     |  Requires all given C{ParseExpression}s to be found in the given order.
     |  Expressions may be separated by whitespace.
     |  May be constructed using the C{'+'} operator.
     |  May also be constructed using the C{'-'} operator, which will suppress backtracking.
     |  
     |  Example::
     |      integer = Word(nums)
     |      name_expr = OneOrMore(Word(alphas))
     |  
     |      expr = And([integer("id"),name_expr("name"),integer("age")])
     |      # more easily written as:
     |      expr = integer("id") + name_expr("name") + integer("age")
     |  
     |  Method resolution order:
     |      And
     |      ParseExpression
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __iadd__(self, other)
     |  
     |  __init__(self, exprs, savelist=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseExpression:
     |  
     |  __getitem__(self, i)
     |  
     |  append(self, other)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
     |      all contained expressions.
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class CaselessKeyword(Keyword)
     |  Caseless version of L{Keyword}.
     |  
     |  Example::
     |      OneOrMore(CaselessKeyword("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD']
     |      
     |  (Contrast with example for L{CaselessLiteral}.)
     |  
     |  Method resolution order:
     |      CaselessKeyword
     |      Keyword
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, matchString, identChars=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Keyword:
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Keyword:
     |  
     |  setDefaultKeywordChars(chars)
     |      Overrides the default Keyword chars
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Keyword:
     |  
     |  DEFAULT_KEYWORD_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class CaselessLiteral(Literal)
     |  Token to match a specified string, ignoring case of letters.
     |  Note: the matched results will always be in the case of the given
     |  match string, NOT the case of the input text.
     |  
     |  Example::
     |      OneOrMore(CaselessLiteral("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD', 'CMD']
     |      
     |  (Contrast with example for L{CaselessKeyword}.)
     |  
     |  Method resolution order:
     |      CaselessLiteral
     |      Literal
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, matchString)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Literal:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class CharsNotIn(Token)
     |  Token for matching words composed of characters I{not} in a given set (will
     |  include whitespace in matched characters if not listed in the provided exclusion set - see example).
     |  Defined with string containing all disallowed characters, and an optional
     |  minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a
     |  minimum value < 1 is not valid); the default values for C{max} and C{exact}
     |  are 0, meaning no maximum or exact length restriction.
     |  
     |  Example::
     |      # define a comma-separated-value as anything that is not a ','
     |      csv_value = CharsNotIn(',')
     |      print(delimitedList(csv_value).parseString("dkls,lsdkjf,s12 34,@!#,213"))
     |  prints::
     |      ['dkls', 'lsdkjf', 's12 34', '@!#', '213']
     |  
     |  Method resolution order:
     |      CharsNotIn
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, notChars, min=1, max=0, exact=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class CloseMatch(Token)
     |  A variation on L{Literal} which matches "close" matches, that is, 
     |  strings with at most 'n' mismatching characters. C{CloseMatch} takes parameters:
     |   - C{match_string} - string to be matched
     |   - C{maxMismatches} - (C{default=1}) maximum number of mismatches allowed to count as a match
     |  
     |  The results from a successful parse will contain the matched text from the input string and the following named results:
     |   - C{mismatches} - a list of the positions within the match_string where mismatches were found
     |   - C{original} - the original match_string used to compare against the input string
     |  
     |  If C{mismatches} is an empty list, then the match was an exact match.
     |  
     |  Example::
     |      patt = CloseMatch("ATCATCGAATGGA")
     |      patt.parseString("ATCATCGAAXGGA") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})
     |      patt.parseString("ATCAXCGAAXGGA") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)
     |  
     |      # exact match
     |      patt.parseString("ATCATCGAATGGA") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})
     |  
     |      # close match allowing up to 2 mismatches
     |      patt = CloseMatch("ATCATCGAATGGA", maxMismatches=2)
     |      patt.parseString("ATCAXCGAAXGGA") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})
     |  
     |  Method resolution order:
     |      CloseMatch
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, match_string, maxMismatches=1)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Combine(TokenConverter)
     |  Converter to concatenate all matching tokens to a single string.
     |  By default, the matching patterns must also be contiguous in the input string;
     |  this can be disabled by specifying C{'adjacent=False'} in the constructor.
     |  
     |  Example::
     |      real = Word(nums) + '.' + Word(nums)
     |      print(real.parseString('3.1416')) # -> ['3', '.', '1416']
     |      # will also erroneously match the following
     |      print(real.parseString('3. 1416')) # -> ['3', '.', '1416']
     |  
     |      real = Combine(Word(nums) + '.' + Word(nums))
     |      print(real.parseString('3.1416')) # -> ['3.1416']
     |      # no match when there are internal spaces
     |      print(real.parseString('3. 1416')) # -> Exception: Expected W:(0123...)
     |  
     |  Method resolution order:
     |      Combine
     |      TokenConverter
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr, joinString='', adjacent=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Dict(TokenConverter)
     |  Converter to return a repetitive expression as a list, but also as a dictionary.
     |  Each element can also be referenced using the first token in the expression as its key.
     |  Useful for tabular report scraping when the first column can be used as a item key.
     |  
     |  Example::
     |      data_word = Word(alphas)
     |      label = data_word + FollowedBy(':')
     |      attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))
     |  
     |      text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
     |      attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
     |      
     |      # print attributes as plain groups
     |      print(OneOrMore(attr_expr).parseString(text).dump())
     |      
     |      # instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names
     |      result = Dict(OneOrMore(Group(attr_expr))).parseString(text)
     |      print(result.dump())
     |      
     |      # access named fields as dict entries, or output as dict
     |      print(result['shape'])        
     |      print(result.asDict())
     |  prints::
     |      ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']
     |  
     |      [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
     |      - color: light blue
     |      - posn: upper left
     |      - shape: SQUARE
     |      - texture: burlap
     |      SQUARE
     |      {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}
     |  See more examples at L{ParseResults} of accessing fields by results name.
     |  
     |  Method resolution order:
     |      Dict
     |      TokenConverter
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Each(ParseExpression)
     |  Requires all given C{ParseExpression}s to be found, but in any order.
     |  Expressions may be separated by whitespace.
     |  May be constructed using the C{'&'} operator.
     |  
     |  Example::
     |      color = oneOf("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
     |      shape_type = oneOf("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
     |      integer = Word(nums)
     |      shape_attr = "shape:" + shape_type("shape")
     |      posn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
     |      color_attr = "color:" + color("color")
     |      size_attr = "size:" + integer("size")
     |  
     |      # use Each (using operator '&') to accept attributes in any order 
     |      # (shape and posn are required, color and size are optional)
     |      shape_spec = shape_attr & posn_attr & Optional(color_attr) & Optional(size_attr)
     |  
     |      shape_spec.runTests('''
     |          shape: SQUARE color: BLACK posn: 100, 120
     |          shape: CIRCLE size: 50 color: BLUE posn: 50,80
     |          color:GREEN size:20 shape:TRIANGLE posn:20,40
     |          '''
     |          )
     |  prints::
     |      shape: SQUARE color: BLACK posn: 100, 120
     |      ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
     |      - color: BLACK
     |      - posn: ['100', ',', '120']
     |        - x: 100
     |        - y: 120
     |      - shape: SQUARE
     |  
     |  
     |      shape: CIRCLE size: 50 color: BLUE posn: 50,80
     |      ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
     |      - color: BLUE
     |      - posn: ['50', ',', '80']
     |        - x: 50
     |        - y: 80
     |      - shape: CIRCLE
     |      - size: 50
     |  
     |  
     |      color: GREEN size: 20 shape: TRIANGLE posn: 20,40
     |      ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
     |      - color: GREEN
     |      - posn: ['20', ',', '40']
     |        - x: 20
     |        - y: 40
     |      - shape: TRIANGLE
     |      - size: 20
     |  
     |  Method resolution order:
     |      Each
     |      ParseExpression
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, exprs, savelist=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseExpression:
     |  
     |  __getitem__(self, i)
     |  
     |  append(self, other)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
     |      all contained expressions.
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Empty(Token)
     |  An empty token, will always match.
     |  
     |  Method resolution order:
     |      Empty
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class FollowedBy(ParseElementEnhance)
     |  Lookahead matching of the given parse expression.  C{FollowedBy}
     |  does I{not} advance the parsing position within the input string, it only
     |  verifies that the specified parse expression matches at the current
     |  position.  C{FollowedBy} always returns a null token list.
     |  
     |  Example::
     |      # use FollowedBy to match a label only if it is followed by a ':'
     |      data_word = Word(alphas)
     |      label = data_word + FollowedBy(':')
     |      attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
     |      
     |      OneOrMore(attr_expr).parseString("shape: SQUARE color: BLACK posn: upper left").pprint()
     |  prints::
     |      [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]
     |  
     |  Method resolution order:
     |      FollowedBy
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Forward(ParseElementEnhance)
     |  Forward declaration of an expression to be defined later -
     |  used for recursive grammars, such as algebraic infix notation.
     |  When the expression is known, it is assigned to the C{Forward} variable using the '<<' operator.
     |  
     |  Note: take care when assigning to C{Forward} not to overlook precedence of operators.
     |  Specifically, '|' has a lower precedence than '<<', so that::
     |      fwdExpr << a | b | c
     |  will actually be evaluated as::
     |      (fwdExpr << a) | b | c
     |  thereby leaving b and c out as parseable alternatives.  It is recommended that you
     |  explicitly group the values inserted into the C{Forward}::
     |      fwdExpr << (a | b | c)
     |  Converting to use the '<<=' operator instead will avoid this problem.
     |  
     |  See L{ParseResults.pprint} for an example of a recursive parser created using
     |  C{Forward}.
     |  
     |  Method resolution order:
     |      Forward
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __ilshift__(self, other)
     |  
     |  __init__(self, other=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __lshift__(self, other)
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class GoToColumn(_PositionToken)
     |  Token to advance to a specific column of input text; useful for tabular report scraping.
     |  
     |  Method resolution order:
     |      GoToColumn
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colno)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  preParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Group(TokenConverter)
     |  Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions.
     |  
     |  Example::
     |      ident = Word(alphas)
     |      num = Word(nums)
     |      term = ident | num
     |      func = ident + Optional(delimitedList(term))
     |      print(func.parseString("fn a,b,100"))  # -> ['fn', 'a', 'b', '100']
     |  
     |      func = ident + Group(Optional(delimitedList(term)))
     |      print(func.parseString("fn a,b,100"))  # -> ['fn', ['a', 'b', '100']]
     |  
     |  Method resolution order:
     |      Group
     |      TokenConverter
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Keyword(Token)
     |  Token to exactly match a specified string as a keyword, that is, it must be
     |  immediately followed by a non-keyword character.  Compare with C{L{Literal}}:
     |   - C{Literal("if")} will match the leading C{'if'} in C{'ifAndOnlyIf'}.
     |   - C{Keyword("if")} will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}
     |  Accepts two optional constructor arguments in addition to the keyword string:
     |   - C{identChars} is a string of characters that would be valid identifier characters,
     |        defaulting to all alphanumerics + "_" and "$"
     |   - C{caseless} allows case-insensitive matching, default is C{False}.
     |     
     |  Example::
     |      Keyword("start").parseString("start")  # -> ['start']
     |      Keyword("start").parseString("starting")  # -> Exception
     |  
     |  For case-insensitive matching, use L{CaselessKeyword}.
     |  
     |  Method resolution order:
     |      Keyword
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, matchString, identChars=None, caseless=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  setDefaultKeywordChars(chars)
     |      Overrides the default Keyword chars
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  DEFAULT_KEYWORD_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class LineEnd(_PositionToken)
     |  Matches if current position is at the end of a line within the parse string
     |  
     |  Method resolution order:
     |      LineEnd
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class LineStart(_PositionToken)
     |  Matches if current position is at the beginning of a line within the parse string
     |  
     |  Example::
     |  
     |      test = '''        AAA this line
     |      AAA and this line
     |        AAA but not this one
     |      B AAA and definitely not this one
     |      '''
     |  
     |      for t in (LineStart() + 'AAA' + restOfLine).searchString(test):
     |          print(t)
     |  
     |  Prints::
     |      ['AAA', ' this line']
     |      ['AAA', ' and this line']
     |  
     |  Method resolution order:
     |      LineStart
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Literal(Token)
     |  Token to exactly match a specified string.
     |  
     |  Example::
     |      Literal('blah').parseString('blah')  # -> ['blah']
     |      Literal('blah').parseString('blahfooblah')  # -> ['blah']
     |      Literal('blah').parseString('bla')  # -> Exception: Expected "blah"
     |  
     |  For case-insensitive matching, use L{CaselessLiteral}.
     |  
     |  For keyword matching (force word break before and after the matched string),
     |  use L{Keyword} or L{CaselessKeyword}.
     |  
     |  Method resolution order:
     |      Literal
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, matchString)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |      # Performance tuning: this routine gets called a *lot*
     |      # if this is a single character match string  and the first character matches,
     |      # short-circuit as quickly as possible, and avoid calling startswith
     |      #~ @profile
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class MatchFirst(ParseExpression)
     |  Requires that at least one C{ParseExpression} is found.
     |  If two expressions match, the first one listed is the one that will match.
     |  May be constructed using the C{'|'} operator.
     |  
     |  Example::
     |      # construct MatchFirst using '|' operator
     |      
     |      # watch the order of expressions to match
     |      number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
     |      print(number.searchString("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]
     |  
     |      # put more selective expression first
     |      number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
     |      print(number.searchString("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
     |  
     |  Method resolution order:
     |      MatchFirst
     |      ParseExpression
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, exprs, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __ior__(self, other)
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseExpression:
     |  
     |  __getitem__(self, i)
     |  
     |  append(self, other)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
     |      all contained expressions.
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class NoMatch(Token)
     |  A token that will never match.
     |  
     |  Method resolution order:
     |      NoMatch
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class NotAny(ParseElementEnhance)
     |  Lookahead to disallow matching with the given parse expression.  C{NotAny}
     |  does I{not} advance the parsing position within the input string, it only
     |  verifies that the specified parse expression does I{not} match at the current
     |  position.  Also, C{NotAny} does I{not} skip over leading whitespace. C{NotAny}
     |  always returns a null token list.  May be constructed using the '~' operator.
     |  
     |  Example::
     |  
     |  Method resolution order:
     |      NotAny
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class OneOrMore(_MultipleMatch)
     |  Repetition of one or more of the given expression.
     |  
     |  Parameters:
     |   - expr - expression that must match one or more times
     |   - stopOn - (default=C{None}) - expression for a terminating sentinel
     |        (only required if the sentinel would ordinarily match the repetition 
     |        expression)          
     |  
     |  Example::
     |      data_word = Word(alphas)
     |      label = data_word + FollowedBy(':')
     |      attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))
     |  
     |      text = "shape: SQUARE posn: upper left color: BLACK"
     |      OneOrMore(attr_expr).parseString(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]
     |  
     |      # use stopOn attribute for OneOrMore to avoid reading label string as part of the data
     |      attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
     |      OneOrMore(attr_expr).parseString(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]
     |      
     |      # could also be written as
     |      (attr_expr * (1,)).parseString(text).pprint()
     |  
     |  Method resolution order:
     |      OneOrMore
     |      _MultipleMatch
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _MultipleMatch:
     |  
     |  __init__(self, expr, stopOn=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class OnlyOnce(builtins.object)
     |  Wrapper for parse actions, to ensure they are only called once.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, s, l, t)
     |      Call self as a function.
     |  
     |  __init__(self, methodCall)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  reset(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Optional(ParseElementEnhance)
     |  Optional matching of the given expression.
     |  
     |  Parameters:
     |   - expr - expression that must match zero or more times
     |   - default (optional) - value to be returned if the optional expression is not found.
     |  
     |  Example::
     |      # US postal code can be a 5-digit zip, plus optional 4-digit qualifier
     |      zip = Combine(Word(nums, exact=5) + Optional('-' + Word(nums, exact=4)))
     |      zip.runTests('''
     |          # traditional ZIP code
     |          12345
     |          
     |          # ZIP+4 form
     |          12101-0001
     |          
     |          # invalid ZIP
     |          98765-
     |          ''')
     |  prints::
     |      # traditional ZIP code
     |      12345
     |      ['12345']
     |  
     |      # ZIP+4 form
     |      12101-0001
     |      ['12101-0001']
     |  
     |      # invalid ZIP
     |      98765-
     |           ^
     |      FAIL: Expected end of text (at char 5), (line:1, col:6)
     |  
     |  Method resolution order:
     |      Optional
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr, default=<pyparsing._NullToken object at 0x00000255ECEC6828>)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Or(ParseExpression)
     |  Requires that at least one C{ParseExpression} is found.
     |  If two expressions match, the expression that matches the longest string will be used.
     |  May be constructed using the C{'^'} operator.
     |  
     |  Example::
     |      # construct Or using '^' operator
     |      
     |      number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
     |      print(number.searchString("123 3.1416 789"))
     |  prints::
     |      [['123'], ['3.1416'], ['789']]
     |  
     |  Method resolution order:
     |      Or
     |      ParseExpression
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, exprs, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __ixor__(self, other)
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseExpression:
     |  
     |  __getitem__(self, i)
     |  
     |  append(self, other)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
     |      all contained expressions.
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class ParseBaseException(builtins.Exception)
     |  base exception class for all parsing runtime exceptions
     |  
     |  Method resolution order:
     |      ParseBaseException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __dir__(self)
     |      __dir__() -> list
     |      default dir() implementation
     |  
     |  __getattr__(self, aname)
     |      supported attributes by name are:
     |      - lineno - returns the line number of the exception text
     |      - col - returns the column number of the exception text
     |      - line - returns the line containing the exception text
     |  
     |  __init__(self, pstr, loc=0, msg=None, elem=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  markInputline(self, markerString='>!<')
     |      Extracts the exception line from the input string, and marks
     |      the location of the exception with a special symbol.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ParseElementEnhance(ParserElement)
     |  Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens.
     |  
     |  Method resolution order:
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class ParseException(ParseBaseException)
     |  Exception thrown when parse expressions don't match class;
     |  supported attributes by name are:
     |   - lineno - returns the line number of the exception text
     |   - col - returns the column number of the exception text
     |   - line - returns the line containing the exception text
     |      
     |  Example::
     |      try:
     |          Word(nums).setName("integer").parseString("ABC")
     |      except ParseException as pe:
     |          print(pe)
     |          print("column: {}".format(pe.col))
     |          
     |  prints::
     |     Expected integer (at char 0), (line:1, col:1)
     |      column: 1
     |  
     |  Method resolution order:
     |      ParseException
     |      ParseBaseException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from ParseBaseException:
     |  
     |  __dir__(self)
     |      __dir__() -> list
     |      default dir() implementation
     |  
     |  __getattr__(self, aname)
     |      supported attributes by name are:
     |      - lineno - returns the line number of the exception text
     |      - col - returns the column number of the exception text
     |      - line - returns the line containing the exception text
     |  
     |  __init__(self, pstr, loc=0, msg=None, elem=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  markInputline(self, markerString='>!<')
     |      Extracts the exception line from the input string, and marks
     |      the location of the exception with a special symbol.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParseBaseException:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ParseExpression(ParserElement)
     |  Abstract subclass of ParserElement, for combining and post-processing parsed tokens.
     |  
     |  Method resolution order:
     |      ParseExpression
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, i)
     |  
     |  __init__(self, exprs, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  append(self, other)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
     |      all contained expressions.
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class ParseFatalException(ParseBaseException)
     |  user-throwable exception thrown when inconsistent parse content
     |  is found; stops all parsing immediately
     |  
     |  Method resolution order:
     |      ParseFatalException
     |      ParseBaseException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from ParseBaseException:
     |  
     |  __dir__(self)
     |      __dir__() -> list
     |      default dir() implementation
     |  
     |  __getattr__(self, aname)
     |      supported attributes by name are:
     |      - lineno - returns the line number of the exception text
     |      - col - returns the column number of the exception text
     |      - line - returns the line containing the exception text
     |  
     |  __init__(self, pstr, loc=0, msg=None, elem=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  markInputline(self, markerString='>!<')
     |      Extracts the exception line from the input string, and marks
     |      the location of the exception with a special symbol.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParseBaseException:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ParseResults(builtins.object)
     |  Structured parse results, to provide multiple means of access to the parsed data:
     |     - as a list (C{len(results)})
     |     - by list index (C{results[0], results[1]}, etc.)
     |     - by attribute (C{results.<resultsName>} - see L{ParserElement.setResultsName})
     |  
     |  Example::
     |      integer = Word(nums)
     |      date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      # equivalent form:
     |      # date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |      # parseString returns a ParseResults object
     |      result = date_str.parseString("1999/12/31")
     |  
     |      def test(s, fn=repr):
     |          print("%s -> %s" % (s, fn(eval(s))))
     |      test("list(result)")
     |      test("result[0]")
     |      test("result['month']")
     |      test("result.day")
     |      test("'month' in result")
     |      test("'minutes' in result")
     |      test("result.dump()", str)
     |  prints::
     |      list(result) -> ['1999', '/', '12', '/', '31']
     |      result[0] -> '1999'
     |      result['month'] -> '12'
     |      result.day -> '31'
     |      'month' in result -> True
     |      'minutes' in result -> False
     |      result.dump() -> ['1999', '/', '12', '/', '31']
     |      - day: 31
     |      - month: 12
     |      - year: 1999
     |  
     |  Methods defined here:
     |  
     |  __add__(self, other)
     |  
     |  __bool__(self)
     |  
     |  __contains__(self, k)
     |  
     |  __delitem__(self, i)
     |  
     |  __dir__(self)
     |      __dir__() -> list
     |      default dir() implementation
     |  
     |  __getattr__(self, name)
     |  
     |  __getitem__(self, i)
     |  
     |  __getnewargs__(self)
     |  
     |  __getstate__(self)
     |      # add support for pickle protocol
     |  
     |  __iadd__(self, other)
     |  
     |  __init__(self, toklist=None, name=None, asList=True, modal=True, isinstance=<built-in function isinstance>)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self)
     |  
     |  __len__(self)
     |  
     |  __nonzero__ = __bool__(self)
     |  
     |  __radd__(self, other)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __reversed__(self)
     |  
     |  __setitem__(self, k, v, isinstance=<built-in function isinstance>)
     |  
     |  __setstate__(self, state)
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  append(self, item)
     |      Add single element to end of ParseResults list of elements.
     |      
     |      Example::
     |          print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']
     |          
     |          # use a parse action to compute the sum of the parsed integers, and add it to the end
     |          def append_sum(tokens):
     |              tokens.append(sum(map(int, tokens)))
     |          print(OneOrMore(Word(nums)).addParseAction(append_sum).parseString("0 123 321")) # -> ['0', '123', '321', 444]
     |  
     |  asDict(self)
     |      Returns the named parse results as a nested dictionary.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |          
     |          result = date_str.parseString('12/31/1999')
     |          print(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})
     |          
     |          result_dict = result.asDict()
     |          print(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}
     |      
     |          # even though a ParseResults supports dict-like access, sometime you just need to have a dict
     |          import json
     |          print(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable
     |          print(json.dumps(result.asDict())) # -> {"month": "31", "day": "1999", "year": "12"}
     |  
     |  asList(self)
     |      Returns the parse results as a nested list of matching tokens, all converted to strings.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          result = patt.parseString("sldkj lsdkj sldkj")
     |          # even though the result prints in string-like form, it is actually a pyparsing ParseResults
     |          print(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']
     |          
     |          # Use asList() to create an actual list
     |          result_list = result.asList()
     |          print(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']
     |  
     |  asXML(self, doctag=None, namedItemsOnly=False, indent='', formatted=True)
     |      (Deprecated) Returns the parse results as XML. Tags are created for tokens and lists that have defined results names.
     |  
     |  clear(self)
     |      Clear all elements and results names.
     |  
     |  copy(self)
     |      Returns a new copy of a C{ParseResults} object.
     |  
     |  dump(self, indent='', depth=0, full=True)
     |      Diagnostic method for listing out the contents of a C{ParseResults}.
     |      Accepts an optional C{indent} argument so that this string can be embedded
     |      in a nested display of other data.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |          
     |          result = date_str.parseString('12/31/1999')
     |          print(result.dump())
     |      prints::
     |          ['12', '/', '31', '/', '1999']
     |          - day: 1999
     |          - month: 31
     |          - year: 12
     |  
     |  extend(self, itemseq)
     |      Add sequence of elements to end of ParseResults list of elements.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          
     |          # use a parse action to append the reverse of the matched strings, to make a palindrome
     |          def make_palindrome(tokens):
     |              tokens.extend(reversed([t[::-1] for t in tokens]))
     |              return ''.join(tokens)
     |          print(patt.addParseAction(make_palindrome).parseString("lskdj sdlkjf lksd")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'
     |  
     |  get(self, key, defaultValue=None)
     |      Returns named result matching the given key, or if there is no
     |      such name, then returns the given C{defaultValue} or C{None} if no
     |      C{defaultValue} is specified.
     |      
     |      Similar to C{dict.get()}.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          result = date_str.parseString("1999/12/31")
     |          print(result.get("year")) # -> '1999'
     |          print(result.get("hour", "not specified")) # -> 'not specified'
     |          print(result.get("hour")) # -> None
     |  
     |  getName(self)
     |      Returns the results name for this token expression. Useful when several 
     |      different expressions might match at a particular location.
     |      
     |      Example::
     |          integer = Word(nums)
     |          ssn_expr = Regex(r"\d\d\d-\d\d-\d\d\d\d")
     |          house_number_expr = Suppress('#') + Word(nums, alphanums)
     |          user_data = (Group(house_number_expr)("house_number") 
     |                      | Group(ssn_expr)("ssn")
     |                      | Group(integer)("age"))
     |          user_info = OneOrMore(user_data)
     |          
     |          result = user_info.parseString("22 111-22-3333 #221B")
     |          for item in result:
     |              print(item.getName(), ':', item[0])
     |      prints::
     |          age : 22
     |          ssn : 111-22-3333
     |          house_number : 221B
     |  
     |  haskeys(self)
     |      Since keys() returns an iterator, this method is helpful in bypassing
     |      code that looks for the existence of any defined results names.
     |  
     |  insert(self, index, insStr)
     |      Inserts new element at location index in the list of parsed tokens.
     |      
     |      Similar to C{list.insert()}.
     |      
     |      Example::
     |          print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']
     |      
     |          # use a parse action to insert the parse location in the front of the parsed results
     |          def insert_locn(locn, tokens):
     |              tokens.insert(0, locn)
     |          print(OneOrMore(Word(nums)).addParseAction(insert_locn).parseString("0 123 321")) # -> [0, '0', '123', '321']
     |  
     |  items = _iteritems(self)
     |  
     |  keys = _iterkeys(self)
     |  
     |  pop(self, *args, **kwargs)
     |      Removes and returns item at specified index (default=C{last}).
     |      Supports both C{list} and C{dict} semantics for C{pop()}. If passed no
     |      argument or an integer argument, it will use C{list} semantics
     |      and pop tokens from the list of parsed tokens. If passed a 
     |      non-integer argument (most likely a string), it will use C{dict}
     |      semantics and pop the corresponding value from any defined 
     |      results names. A second default return value argument is 
     |      supported, just as in C{dict.pop()}.
     |      
     |      Example::
     |          def remove_first(tokens):
     |              tokens.pop(0)
     |          print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']
     |          print(OneOrMore(Word(nums)).addParseAction(remove_first).parseString("0 123 321")) # -> ['123', '321']
     |      
     |          label = Word(alphas)
     |          patt = label("LABEL") + OneOrMore(Word(nums))
     |          print(patt.parseString("AAB 123 321").dump())
     |      
     |          # Use pop() in a parse action to remove named result (note that corresponding value is not
     |          # removed from list form of results)
     |          def remove_LABEL(tokens):
     |              tokens.pop("LABEL")
     |              return tokens
     |          patt.addParseAction(remove_LABEL)
     |          print(patt.parseString("AAB 123 321").dump())
     |      prints::
     |          ['AAB', '123', '321']
     |          - LABEL: AAB
     |      
     |          ['AAB', '123', '321']
     |  
     |  pprint(self, *args, **kwargs)
     |      Pretty-printer for parsed results as a list, using the C{pprint} module.
     |      Accepts additional positional or keyword args as defined for the 
     |      C{pprint.pprint} method. (U{http://docs.python.org/3/library/pprint.html#pprint.pprint})
     |      
     |      Example::
     |          ident = Word(alphas, alphanums)
     |          num = Word(nums)
     |          func = Forward()
     |          term = ident | num | Group('(' + func + ')')
     |          func <<= ident + Group(Optional(delimitedList(term)))
     |          result = func.parseString("fna a,b,(fnb c,d,200),100")
     |          result.pprint(width=40)
     |      prints::
     |          ['fna',
     |           ['a',
     |            'b',
     |            ['(', 'fnb', ['c', 'd', '200'], ')'],
     |            '100']]
     |  
     |  values = _itervalues(self)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls, toklist=None, name=None, asList=True, modal=True)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ParseSyntaxException(ParseFatalException)
     |  just like L{ParseFatalException}, but thrown internally when an
     |  L{ErrorStop<And._ErrorStop>} ('-' operator) indicates that parsing is to stop 
     |  immediately because an unbacktrackable syntax error has been found
     |  
     |  Method resolution order:
     |      ParseSyntaxException
     |      ParseFatalException
     |      ParseBaseException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from ParseBaseException:
     |  
     |  __dir__(self)
     |      __dir__() -> list
     |      default dir() implementation
     |  
     |  __getattr__(self, aname)
     |      supported attributes by name are:
     |      - lineno - returns the line number of the exception text
     |      - col - returns the column number of the exception text
     |      - line - returns the line containing the exception text
     |  
     |  __init__(self, pstr, loc=0, msg=None, elem=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  markInputline(self, markerString='>!<')
     |      Extracts the exception line from the input string, and marks
     |      the location of the exception with a special symbol.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParseBaseException:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ParserElement(builtins.object)
     |  Abstract base level parser element class.
     |  
     |  Methods defined here:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class QuotedString(Token)
     |  Token for matching strings that are delimited by quoting characters.
     |  
     |  Defined with the following parameters:
     |      - quoteChar - string of one or more characters defining the quote delimiting string
     |      - escChar - character to escape quotes, typically backslash (default=C{None})
     |      - escQuote - special quote sequence to escape an embedded quote string (such as SQL's "" to escape an embedded ") (default=C{None})
     |      - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})
     |      - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})
     |      - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} => same as quoteChar)
     |      - convertWhitespaceEscapes - convert escaped whitespace (C{'\t'}, C{'\n'}, etc.) to actual whitespace (default=C{True})
     |  
     |  Example::
     |      qs = QuotedString('"')
     |      print(qs.searchString('lsjdf "This is the quote" sldjf'))
     |      complex_qs = QuotedString('{{', endQuoteChar='}}')
     |      print(complex_qs.searchString('lsjdf {{This is the "quote"}} sldjf'))
     |      sql_qs = QuotedString('"', escQuote='""')
     |      print(sql_qs.searchString('lsjdf "This is the quote with ""embedded"" quotes" sldjf'))
     |  prints::
     |      [['This is the quote']]
     |      [['This is the "quote"']]
     |      [['This is the quote with "embedded" quotes']]
     |  
     |  Method resolution order:
     |      QuotedString
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None, convertWhitespaceEscapes=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class RecursiveGrammarException(builtins.Exception)
     |  exception thrown by L{ParserElement.validate} if the grammar could be improperly recursive
     |  
     |  Method resolution order:
     |      RecursiveGrammarException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, parseElementList)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class Regex(Token)
     |  Token for matching strings that match a given regular expression.
     |  Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |  If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |  named parse results.
     |  
     |  Example::
     |      realnum = Regex(r"[+-]?\d+\.\d*")
     |      date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |      # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |      roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  Method resolution order:
     |      Regex
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, pattern, flags=0)
     |      The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  compiledREtype = <class '_sre.SRE_Pattern'>
     |      Compiled regular expression objects
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class SkipTo(ParseElementEnhance)
     |  Token for skipping over all undefined text until the matched expression is found.
     |  
     |  Parameters:
     |   - expr - target expression marking the end of the data to be skipped
     |   - include - (default=C{False}) if True, the target expression is also parsed 
     |        (the skipped text and target expression are returned as a 2-element list).
     |   - ignore - (default=C{None}) used to define grammars (typically quoted strings and 
     |        comments) that might contain false matches to the target expression
     |   - failOn - (default=C{None}) define expressions that are not allowed to be 
     |        included in the skipped test; if found before the target expression is found, 
     |        the SkipTo is not a match
     |  
     |  Example::
     |      report = '''
     |          Outstanding Issues Report - 1 Jan 2000
     |  
     |             # | Severity | Description                               |  Days Open
     |          -----+----------+-------------------------------------------+-----------
     |           101 | Critical | Intermittent system crash                 |          6
     |            94 | Cosmetic | Spelling error on Login ('log|n')         |         14
     |            79 | Minor    | System slow when running too many reports |         47
     |          '''
     |      integer = Word(nums)
     |      SEP = Suppress('|')
     |      # use SkipTo to simply match everything up until the next SEP
     |      # - ignore quoted strings, so that a '|' character inside a quoted string does not match
     |      # - parse action will call token.strip() for each matched token, i.e., the description body
     |      string_data = SkipTo(SEP, ignore=quotedString)
     |      string_data.setParseAction(tokenMap(str.strip))
     |      ticket_expr = (integer("issue_num") + SEP 
     |                    + string_data("sev") + SEP 
     |                    + string_data("desc") + SEP 
     |                    + integer("days_open"))
     |      
     |      for tkt in ticket_expr.searchString(report):
     |          print tkt.dump()
     |  prints::
     |      ['101', 'Critical', 'Intermittent system crash', '6']
     |      - days_open: 6
     |      - desc: Intermittent system crash
     |      - issue_num: 101
     |      - sev: Critical
     |      ['94', 'Cosmetic', "Spelling error on Login ('log|n')", '14']
     |      - days_open: 14
     |      - desc: Spelling error on Login ('log|n')
     |      - issue_num: 94
     |      - sev: Cosmetic
     |      ['79', 'Minor', 'System slow when running too many reports', '47']
     |      - days_open: 47
     |      - desc: System slow when running too many reports
     |      - issue_num: 79
     |      - sev: Minor
     |  
     |  Method resolution order:
     |      SkipTo
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, other, include=False, ignore=None, failOn=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class StringEnd(_PositionToken)
     |  Matches if current position is at the end of the parse string
     |  
     |  Method resolution order:
     |      StringEnd
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class StringStart(_PositionToken)
     |  Matches if current position is at the beginning of the parse string
     |  
     |  Method resolution order:
     |      StringStart
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Suppress(TokenConverter)
     |  Converter for ignoring the results of a parsed expression.
     |  
     |  Example::
     |      source = "a, b, c,d"
     |      wd = Word(alphas)
     |      wd_list1 = wd + ZeroOrMore(',' + wd)
     |      print(wd_list1.parseString(source))
     |  
     |      # often, delimiters that are useful during parsing are just in the
     |      # way afterward - use Suppress to keep them out of the parsed output
     |      wd_list2 = wd + ZeroOrMore(Suppress(',') + wd)
     |      print(wd_list2.parseString(source))
     |  prints::
     |      ['a', ',', 'b', ',', 'c', ',', 'd']
     |      ['a', 'b', 'c', 'd']
     |  (See also L{delimitedList}.)
     |  
     |  Method resolution order:
     |      Suppress
     |      TokenConverter
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from TokenConverter:
     |  
     |  __init__(self, expr, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Token(ParserElement)
     |  Abstract C{ParserElement} subclass, for defining atomic matching patterns.
     |  
     |  Method resolution order:
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class TokenConverter(ParseElementEnhance)
     |  Abstract subclass of C{ParseExpression}, for converting parsed results.
     |  
     |  Method resolution order:
     |      TokenConverter
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr, savelist=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class White(Token)
     |  Special matching class for matching whitespace.  Normally, whitespace is ignored
     |  by pyparsing grammars.  This class is included when some whitespace structures
     |  are significant.  Define with a string containing the whitespace characters to be
     |  matched; default is C{" \t\r\n"}.  Also takes optional C{min}, C{max}, and C{exact} arguments,
     |  as defined for the C{L{Word}} class.
     |  
     |  Method resolution order:
     |      White
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, ws=' \t\r\n', min=1, max=0, exact=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  whiteStrs = {'\t': '<TAB>', '\n': '<LF>', '\x0c': '<FF>', '\r': '<CR>'...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class Word(Token)
     |  Token for matching words composed of allowed character sets.
     |  Defined with string containing all allowed initial characters,
     |  an optional string containing allowed body characters (if omitted,
     |  defaults to the initial character set), and an optional minimum,
     |  maximum, and/or exact length.  The default value for C{min} is 1 (a
     |  minimum value < 1 is not valid); the default values for C{max} and C{exact}
     |  are 0, meaning no maximum or exact length restriction. An optional
     |  C{excludeChars} parameter can list characters that might be found in 
     |  the input C{bodyChars} string; useful to define a word of all printables
     |  except for one or two characters, for instance.
     |  
     |  L{srange} is useful for defining custom character set strings for defining 
     |  C{Word} expressions, using range notation from regular expression character sets.
     |  
     |  A common mistake is to use C{Word} to match a specific literal string, as in 
     |  C{Word("Address")}. Remember that C{Word} uses the string argument to define
     |  I{sets} of matchable characters. This expression would match "Add", "AAA",
     |  "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
     |  To match an exact literal string, use L{Literal} or L{Keyword}.
     |  
     |  pyparsing includes helper strings for building Words:
     |   - L{alphas}
     |   - L{nums}
     |   - L{alphanums}
     |   - L{hexnums}
     |   - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     |   - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     |   - L{printables} (any non-whitespace character)
     |  
     |  Example::
     |      # a word composed of digits
     |      integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
     |      
     |      # a word with a leading capital, and zero or more lowercase
     |      capital_word = Word(alphas.upper(), alphas.lower())
     |  
     |      # hostnames are alphanumeric, with leading alpha, and '-'
     |      hostname = Word(alphas, alphanums+'-')
     |      
     |      # roman numeral (not a strict parser, accepts invalid mix of characters)
     |      roman = Word("IVXLCDM")
     |      
     |      # any string of non-whitespace characters, except for ','
     |      csv_value = Word(printables, excludeChars=",")
     |  
     |  Method resolution order:
     |      Word
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class WordEnd(_PositionToken)
     |  Matches if the current position is at the end of a Word, and
     |  is not followed by any character in a given set of C{wordChars}
     |  (default=C{printables}). To emulate the C} behavior of regular expressions,
     |  use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of
     |  the string being parsed, or at the end of a line.
     |  
     |  Method resolution order:
     |      WordEnd
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, wordChars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class WordStart(_PositionToken)
     |  Matches if the current position is at the beginning of a Word, and
     |  is not preceded by any character in a given set of C{wordChars}
     |  (default=C{printables}). To emulate the C} behavior of regular expressions,
     |  use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of
     |  the string being parsed, or at the beginning of a line.
     |  
     |  Method resolution order:
     |      WordStart
     |      _PositionToken
     |      Token
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, wordChars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  streamline(self)
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class ZeroOrMore(_MultipleMatch)
     |  Optional repetition of zero or more of the given expression.
     |  
     |  Parameters:
     |   - expr - expression that must match zero or more times
     |   - stopOn - (default=C{None}) - expression for a terminating sentinel
     |        (only required if the sentinel would ordinarily match the repetition 
     |        expression)          
     |  
     |  Example: similar to L{OneOrMore}
     |  
     |  Method resolution order:
     |      ZeroOrMore
     |      _MultipleMatch
     |      ParseElementEnhance
     |      ParserElement
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expr, stopOn=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  parseImpl(self, instring, loc, doActions=True)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParseElementEnhance:
     |  
     |  checkRecursion(self, parseElementList)
     |  
     |  ignore(self, other)
     |      Define expression to be ignored (e.g., comments) while doing pattern
     |      matching; may be called repeatedly, to define multiple comment or other
     |      ignorable patterns.
     |      
     |      Example::
     |          patt = OneOrMore(Word(alphas))
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
     |          
     |          patt.ignore(cStyleComment)
     |          patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
     |  
     |  leaveWhitespace(self)
     |      Disables the skipping of whitespace before matching the characters in the
     |      C{ParserElement}'s defined pattern.  This is normally only used internally by
     |      the pyparsing module, but may be needed in some whitespace-sensitive grammars.
     |  
     |  streamline(self)
     |  
     |  validate(self, validateTrace=[])
     |      Check defined expressions for valid structure, check for infinite recursive definitions.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ParserElement:
     |  
     |  __add__(self, other)
     |      Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
     |      converts them to L{Literal}s by default.
     |      
     |      Example::
     |          greet = Word(alphas) + "," + Word(alphas) + "!"
     |          hello = "Hello, World!"
     |          print (hello, "->", greet.parseString(hello))
     |      Prints::
     |          Hello, World! -> ['Hello', ',', 'World', '!']
     |  
     |  __and__(self, other)
     |      Implementation of & operator - returns C{L{Each}}
     |  
     |  __call__(self, name=None)
     |      Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
     |      
     |      If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
     |      passed as C{True}.
     |         
     |      If C{name} is omitted, same as calling C{L{copy}}.
     |      
     |      Example::
     |          # these are equivalent
     |          userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
     |          userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __invert__(self)
     |      Implementation of ~ operator - returns C{L{NotAny}}
     |  
     |  __mul__(self, other)
     |      Implementation of * operator, allows use of C{expr * 3} in place of
     |      C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
     |      tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
     |      may also include C{None} as in:
     |       - C{expr*(n,None)} or C{expr*(n,)} is equivalent
     |            to C{expr*n + L{ZeroOrMore}(expr)}
     |            (read as "at least n instances of C{expr}")
     |       - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
     |            (read as "0 to n instances of C{expr}")
     |       - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
     |       - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}
     |      
     |      Note that C{expr*(None,n)} does not raise an exception if
     |      more than n exprs exist in the input stream; that is,
     |      C{expr*(None,n)} does not enforce a maximum number of expr
     |      occurrences.  If this behavior is desired, then write
     |      C{expr*(None,n) + ~expr}
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __or__(self, other)
     |      Implementation of | operator - returns C{L{MatchFirst}}
     |  
     |  __radd__(self, other)
     |      Implementation of + operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rand__(self, other)
     |      Implementation of & operator when left operand is not a C{L{ParserElement}}
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __req__(self, other)
     |  
     |  __rmul__(self, other)
     |  
     |  __rne__(self, other)
     |  
     |  __ror__(self, other)
     |      Implementation of | operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rsub__(self, other)
     |      Implementation of - operator when left operand is not a C{L{ParserElement}}
     |  
     |  __rxor__(self, other)
     |      Implementation of ^ operator when left operand is not a C{L{ParserElement}}
     |  
     |  __sub__(self, other)
     |      Implementation of - operator, returns C{L{And}} with error stop
     |  
     |  __xor__(self, other)
     |      Implementation of ^ operator - returns C{L{Or}}
     |  
     |  addCondition(self, *fns, **kwargs)
     |      Add a boolean predicate function to expression's list of parse actions. See 
     |      L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
     |      functions passed to C{addCondition} need to return boolean success/fail of the condition.
     |      
     |      Optional keyword arguments:
     |       - message = define a custom message to be used in the raised exception
     |       - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
     |       
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          year_int = integer.copy()
     |          year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
     |          date_str = year_int + '/' + integer + '/' + integer
     |      
     |          result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
     |  
     |  addParseAction(self, *fns, **kwargs)
     |      Add one or more parse actions to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
     |      
     |      See examples in L{I{copy}<copy>}.
     |  
     |  canParseNext(self, instring, loc)
     |  
     |  copy(self)
     |      Make a copy of this C{ParserElement}.  Useful for defining different parse actions
     |      for the same parsing pattern, using copies of the original parse element.
     |      
     |      Example::
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
     |          integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |          
     |          print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
     |      prints::
     |          [5120, 100, 655360, 268435456]
     |      Equivalent form of C{expr.copy()} is just C{expr()}::
     |          integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
     |  
     |  matches(self, testString, parseAll=True)
     |      Method for quick testing of a parser against a test string. Good for simple 
     |      inline microtests of sub expressions while building up larger parser.
     |         
     |      Parameters:
     |       - testString - to test against this expression for a match
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
     |          
     |      Example::
     |          expr = Word(nums)
     |          assert expr.matches("100")
     |  
     |  parseFile(self, file_or_filename, parseAll=False)
     |      Execute the parse expression on the given file or filename.
     |      If a filename is specified (instead of a file object),
     |      the entire file is opened, read, and closed before parsing.
     |  
     |  parseString(self, instring, parseAll=False)
     |      Execute the parse expression with the given string.
     |      This is the main interface to the client code, once the complete
     |      expression has been built.
     |      
     |      If you want the grammar to require that the entire input string be
     |      successfully parsed, then set C{parseAll} to True (equivalent to ending
     |      the grammar with C{L{StringEnd()}}).
     |      
     |      Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
     |      in order to report proper column numbers in parse actions.
     |      If the input string contains tabs and
     |      the grammar uses parse actions that use the C{loc} argument to index into the
     |      string being parsed, you can ensure you have a consistent view of the input
     |      string by:
     |       - calling C{parseWithTabs} on your grammar before calling C{parseString}
     |         (see L{I{parseWithTabs}<parseWithTabs>})
     |       - define your parse action using the full C{(s,loc,toks)} signature, and
     |         reference the input string using the parse action's C{s} argument
     |       - explictly expand the tabs in your input string before calling
     |         C{parseString}
     |      
     |      Example::
     |          Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
     |          Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
     |  
     |  parseWithTabs(self)
     |      Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
     |      Must be called before C{parseString} when the input grammar contains elements that
     |      match C{<TAB>} characters.
     |  
     |  postParse(self, instring, loc, tokenlist)
     |  
     |  preParse(self, instring, loc)
     |  
     |  runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False)
     |      Execute the parse expression on a series of test strings, showing each
     |      test, the parsed results or where the parse failed. Quick and easy way to
     |      run a parse expression against a list of sample strings.
     |         
     |      Parameters:
     |       - tests - a list of separate test strings, or a multiline string of test strings
     |       - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
     |       - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
     |            string; pass None to disable comment filtering
     |       - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
     |            if False, only dump nested list
     |       - printResults - (default=C{True}) prints test output to stdout
     |       - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing
     |      
     |      Returns: a (success, results) tuple, where success indicates that all tests succeeded
     |      (or failed if C{failureTests} is True), and the results contain a list of lines of each 
     |      test's output
     |      
     |      Example::
     |          number_expr = pyparsing_common.number.copy()
     |      
     |          result = number_expr.runTests('''
     |              # unsigned integer
     |              100
     |              # negative integer
     |              -100
     |              # float with scientific notation
     |              6.02e23
     |              # integer with scientific notation
     |              1e-12
     |              ''')
     |          print("Success" if result[0] else "Failed!")
     |      
     |          result = number_expr.runTests('''
     |              # stray character
     |              100Z
     |              # missing leading digit before '.'
     |              -.100
     |              # too many '.'
     |              3.14.159
     |              ''', failureTests=True)
     |          print("Success" if result[0] else "Failed!")
     |      prints::
     |          # unsigned integer
     |          100
     |          [100]
     |      
     |          # negative integer
     |          -100
     |          [-100]
     |      
     |          # float with scientific notation
     |          6.02e23
     |          [6.02e+23]
     |      
     |          # integer with scientific notation
     |          1e-12
     |          [1e-12]
     |      
     |          Success
     |          
     |          # stray character
     |          100Z
     |             ^
     |          FAIL: Expected end of text (at char 3), (line:1, col:4)
     |      
     |          # missing leading digit before '.'
     |          -.100
     |          ^
     |          FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)
     |      
     |          # too many '.'
     |          3.14.159
     |              ^
     |          FAIL: Expected end of text (at char 4), (line:1, col:5)
     |      
     |          Success
     |      
     |      Each test string must be on a single line. If you want to test a string that spans multiple
     |      lines, create a test like this::
     |      
     |          expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
     |      
     |      (Note that this is a raw string literal, you must include the leading 'r'.)
     |  
     |  scanString(self, instring, maxMatches=9223372036854775807, overlap=False)
     |      Scan the input string for expression matches.  Each match will return the
     |      matching tokens, start location, and end location.  May be called with optional
     |      C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
     |      C{overlap} is specified, then overlapping matches will be reported.
     |      
     |      Note that the start and end locations are reported relative to the string
     |      being parsed.  See L{I{parseString}<parseString>} for more information on parsing
     |      strings with embedded tabs.
     |      
     |      Example::
     |          source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
     |          print(source)
     |          for tokens,start,end in Word(alphas).scanString(source):
     |              print(' '*start + '^'*(end-start))
     |              print(' '*start + tokens[0])
     |      
     |      prints::
     |      
     |          sldjf123lsdjjkf345sldkjf879lkjsfd987
     |          ^^^^^
     |          sldjf
     |                  ^^^^^^^
     |                  lsdjjkf
     |                            ^^^^^^
     |                            sldkjf
     |                                     ^^^^^^
     |                                     lkjsfd
     |  
     |  searchString(self, instring, maxMatches=9223372036854775807)
     |      Another extension to C{L{scanString}}, simplifying the access to the tokens found
     |      to match the given parse expression.  May be called with optional
     |      C{maxMatches} argument, to clip searching after 'n' matches are found.
     |      
     |      Example::
     |          # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
     |          cap_word = Word(alphas.upper(), alphas.lower())
     |          
     |          print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
     |      
     |          # the sum() builtin can be used to merge results into a single ParseResults object
     |          print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))
     |      prints::
     |          [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
     |          ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
     |  
     |  setBreak(self, breakFlag=True)
     |      Method to invoke the Python pdb debugger when this element is
     |      about to be parsed. Set C{breakFlag} to True to enable, False to
     |      disable.
     |  
     |  setDebug(self, flag=True)
     |      Enable display of debugging messages while doing pattern matching.
     |      Set C{flag} to True to enable, False to disable.
     |      
     |      Example::
     |          wd = Word(alphas).setName("alphaword")
     |          integer = Word(nums).setName("numword")
     |          term = wd | integer
     |          
     |          # turn on debugging for wd
     |          wd.setDebug()
     |      
     |          OneOrMore(term).parseString("abc 123 xyz 890")
     |      
     |      prints::
     |          Match alphaword at loc 0(1,1)
     |          Matched alphaword -> ['abc']
     |          Match alphaword at loc 3(1,4)
     |          Exception raised:Expected alphaword (at char 4), (line:1, col:5)
     |          Match alphaword at loc 7(1,8)
     |          Matched alphaword -> ['xyz']
     |          Match alphaword at loc 11(1,12)
     |          Exception raised:Expected alphaword (at char 12), (line:1, col:13)
     |          Match alphaword at loc 15(1,16)
     |          Exception raised:Expected alphaword (at char 15), (line:1, col:16)
     |      
     |      The output shown is that produced by the default debug actions - custom debug actions can be
     |      specified using L{setDebugActions}. Prior to attempting
     |      to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
     |      is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
     |      message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
     |      which makes debugging and exception messages easier to understand - for instance, the default
     |      name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
     |  
     |  setDebugActions(self, startAction, successAction, exceptionAction)
     |      Enable display of debugging messages while doing pattern matching.
     |  
     |  setFailAction(self, fn)
     |      Define action to perform if parsing fails at this expression.
     |      Fail acton fn is a callable function that takes the arguments
     |      C{fn(s,loc,expr,err)} where:
     |       - s = string being parsed
     |       - loc = location where expression match was attempted and failed
     |       - expr = the parse expression that failed
     |       - err = the exception thrown
     |      The function returns no value.  It may throw C{L{ParseFatalException}}
     |      if it is desired to stop parsing immediately.
     |  
     |  setName(self, name)
     |      Define name for this expression, makes debugging and exception messages clearer.
     |      
     |      Example::
     |          Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
     |          Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
     |  
     |  setParseAction(self, *fns, **kwargs)
     |      Define one or more actions to perform when successfully matching parse element definition.
     |      Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
     |      C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
     |       - s   = the original string being parsed (see note below)
     |       - loc = the location of the matching substring
     |       - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
     |      If the functions in fns modify the tokens, they can return them as the return
     |      value from fn, and the modified list of tokens will replace the original.
     |      Otherwise, fn does not need to return any value.
     |      
     |      Optional keyword arguments:
     |       - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing
     |      
     |      Note: the default parsing behavior is to expand tabs in the input string
     |      before starting the parsing process.  See L{I{parseString}<parseString>} for more information
     |      on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
     |      consistent view of the parsed string, the parse location, and line and column
     |      positions within the parsed string.
     |      
     |      Example::
     |          integer = Word(nums)
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |          # use parse action to convert to ints at parse time
     |          integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
     |          date_str = integer + '/' + integer + '/' + integer
     |      
     |          # note that integer fields are now ints, not strings
     |          date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
     |  
     |  setResultsName(self, name, listAllMatches=False)
     |      Define name for referencing matching tokens as a nested attribute
     |      of the returned parse results.
     |      NOTE: this returns a *copy* of the original C{ParserElement} object;
     |      this is so that the client can define a basic element, such as an
     |      integer, and reference it in multiple places with different names.
     |      
     |      You can also set results names using the abbreviated syntax,
     |      C{expr("name")} in place of C{expr.setResultsName("name")} - 
     |      see L{I{__call__}<__call__>}.
     |      
     |      Example::
     |          date_str = (integer.setResultsName("year") + '/' 
     |                      + integer.setResultsName("month") + '/' 
     |                      + integer.setResultsName("day"))
     |      
     |          # equivalent form:
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
     |  
     |  setWhitespaceChars(self, chars)
     |      Overrides the default whitespace chars
     |  
     |  split(self, instring, maxsplit=9223372036854775807, includeSeparators=False)
     |      Generator method to split a string using the given expression as a separator.
     |      May be called with optional C{maxsplit} argument, to limit the number of splits;
     |      and the optional C{includeSeparators} argument (default=C{False}), if the separating
     |      matching text should be included in the split results.
     |      
     |      Example::        
     |          punc = oneOf(list(".,;:/-!?"))
     |          print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
     |      prints::
     |          ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
     |  
     |  suppress(self)
     |      Suppresses the output of this C{ParserElement}; useful to keep punctuation from
     |      cluttering up returned output.
     |  
     |  transformString(self, instring)
     |      Extension to C{L{scanString}}, to modify matching text with modified tokens that may
     |      be returned from a parse action.  To use C{transformString}, define a grammar and
     |      attach a parse action to it that modifies the returned token list.
     |      Invoking C{transformString()} on a target string will then scan for matches,
     |      and replace the matched text patterns according to the logic in the parse
     |      action.  C{transformString()} returns the resulting transformed string.
     |      
     |      Example::
     |          wd = Word(alphas)
     |          wd.setParseAction(lambda toks: toks[0].title())
     |          
     |          print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
     |      Prints::
     |          Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
     |  
     |  tryParse(self, instring, loc)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from ParserElement:
     |  
     |  enablePackrat(cache_size_limit=128)
     |      Enables "packrat" parsing, which adds memoizing to the parsing logic.
     |      Repeated parse attempts at the same string location (which happens
     |      often in many complex grammars) can immediately return a cached value,
     |      instead of re-executing parsing/validating code.  Memoizing is done of
     |      both valid results and parsing exceptions.
     |      
     |      Parameters:
     |       - cache_size_limit - (default=C{128}) - if an integer value is provided
     |         will limit the size of the packrat cache; if None is passed, then
     |         the cache size will be unbounded; if 0 is passed, the cache will
     |         be effectively disabled.
     |       
     |      This speedup may break existing programs that use parse actions that
     |      have side-effects.  For this reason, packrat parsing is disabled when
     |      you first import pyparsing.  To activate the packrat feature, your
     |      program must call the class method C{ParserElement.enablePackrat()}.  If
     |      your program uses C{psyco} to "compile as you go", you must call
     |      C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
     |      Python will crash.  For best results, call C{enablePackrat()} immediately
     |      after importing pyparsing.
     |      
     |      Example::
     |          import pyparsing
     |          pyparsing.ParserElement.enablePackrat()
     |  
     |  inlineLiteralsUsing(cls)
     |      Set class to be used for inclusion of string literals into a parser.
     |      
     |      Example::
     |          # default literal class used is Literal
     |          integer = Word(nums)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']
     |      
     |      
     |          # change to Suppress
     |          ParserElement.inlineLiteralsUsing(Suppress)
     |          date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           
     |      
     |          date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
     |  
     |  resetCache()
     |  
     |  setDefaultWhitespaceChars(chars)
     |      Overrides the default whitespace chars
     |      
     |      Example::
     |          # default whitespace chars are space, <TAB> and newline
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
     |          
     |          # change to just treat newline as significant
     |          ParserElement.setDefaultWhitespaceChars(" \t")
     |          OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ParserElement:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ParserElement:
     |  
     |  DEFAULT_WHITE_CHARS = ' \n\t\r'
     |  
     |  packrat_cache = {}
     |  
     |  packrat_cache_lock = <unlocked _thread.RLock object owner=0 count=0>
     |  
     |  packrat_cache_stats = [0, 0]
     |  
     |  verbose_stacktrace = False
    
    class pyparsing_common(builtins.object)
     |  Here are some common low-level expressions that may be useful in jump-starting parser development:
     |   - numeric forms (L{integers<integer>}, L{reals<real>}, L{scientific notation<sci_real>})
     |   - common L{programming identifiers<identifier>}
     |   - network addresses (L{MAC<mac_address>}, L{IPv4<ipv4_address>}, L{IPv6<ipv6_address>})
     |   - ISO8601 L{dates<iso8601_date>} and L{datetime<iso8601_datetime>}
     |   - L{UUID<uuid>}
     |   - L{comma-separated list<comma_separated_list>}
     |  Parse actions:
     |   - C{L{convertToInteger}}
     |   - C{L{convertToFloat}}
     |   - C{L{convertToDate}}
     |   - C{L{convertToDatetime}}
     |   - C{L{stripHTMLTags}}
     |   - C{L{upcaseTokens}}
     |   - C{L{downcaseTokens}}
     |  
     |  Example::
     |      pyparsing_common.number.runTests('''
     |          # any int or real number, returned as the appropriate type
     |          100
     |          -100
     |          +100
     |          3.14159
     |          6.02e23
     |          1e-12
     |          ''')
     |  
     |      pyparsing_common.fnumber.runTests('''
     |          # any int or real number, returned as float
     |          100
     |          -100
     |          +100
     |          3.14159
     |          6.02e23
     |          1e-12
     |          ''')
     |  
     |      pyparsing_common.hex_integer.runTests('''
     |          # hex numbers
     |          100
     |          FF
     |          ''')
     |  
     |      pyparsing_common.fraction.runTests('''
     |          # fractions
     |          1/2
     |          -3/4
     |          ''')
     |  
     |      pyparsing_common.mixed_integer.runTests('''
     |          # mixed fractions
     |          1
     |          1/2
     |          -3/4
     |          1-3/4
     |          ''')
     |  
     |      import uuid
     |      pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))
     |      pyparsing_common.uuid.runTests('''
     |          # uuid
     |          12345678-1234-5678-1234-567812345678
     |          ''')
     |  prints::
     |      # any int or real number, returned as the appropriate type
     |      100
     |      [100]
     |  
     |      -100
     |      [-100]
     |  
     |      +100
     |      [100]
     |  
     |      3.14159
     |      [3.14159]
     |  
     |      6.02e23
     |      [6.02e+23]
     |  
     |      1e-12
     |      [1e-12]
     |  
     |      # any int or real number, returned as float
     |      100
     |      [100.0]
     |  
     |      -100
     |      [-100.0]
     |  
     |      +100
     |      [100.0]
     |  
     |      3.14159
     |      [3.14159]
     |  
     |      6.02e23
     |      [6.02e+23]
     |  
     |      1e-12
     |      [1e-12]
     |  
     |      # hex numbers
     |      100
     |      [256]
     |  
     |      FF
     |      [255]
     |  
     |      # fractions
     |      1/2
     |      [0.5]
     |  
     |      -3/4
     |      [-0.75]
     |  
     |      # mixed fractions
     |      1
     |      [1]
     |  
     |      1/2
     |      [0.5]
     |  
     |      -3/4
     |      [-0.75]
     |  
     |      1-3/4
     |      [1.75]
     |  
     |      # uuid
     |      12345678-1234-5678-1234-567812345678
     |      [UUID('12345678-1234-5678-1234-567812345678')]
     |  
     |  Methods defined here:
     |  
     |  convertToFloat = float(s, l, t)
     |  
     |  convertToInteger = int(s, l, t)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  convertToDate(fmt='%Y-%m-%d')
     |      Helper to create a parse action for converting parsed date string to Python datetime.date
     |      
     |      Params -
     |       - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%d"})
     |      
     |      Example::
     |          date_expr = pyparsing_common.iso8601_date.copy()
     |          date_expr.setParseAction(pyparsing_common.convertToDate())
     |          print(date_expr.parseString("1999-12-31"))
     |      prints::
     |          [datetime.date(1999, 12, 31)]
     |  
     |  convertToDatetime(fmt='%Y-%m-%dT%H:%M:%S.%f')
     |      Helper to create a parse action for converting parsed datetime string to Python datetime.datetime
     |      
     |      Params -
     |       - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%dT%H:%M:%S.%f"})
     |      
     |      Example::
     |          dt_expr = pyparsing_common.iso8601_datetime.copy()
     |          dt_expr.setParseAction(pyparsing_common.convertToDatetime())
     |          print(dt_expr.parseString("1999-12-31T23:59:59.999"))
     |      prints::
     |          [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]
     |  
     |  downcaseTokens lambda s, l, t
     |  
     |  stripHTMLTags(s, l, tokens)
     |      Parse action to remove HTML tags from web page HTML source
     |      
     |      Example::
     |          # strip HTML links from normal text 
     |          text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
     |          td,td_end = makeHTMLTags("TD")
     |          table_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)("body") + td_end
     |          
     |          print(table_text.parseString(text).body) # -> 'More info at the pyparsing wiki page'
     |  
     |  upcaseTokens lambda s, l, t
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  comma_separated_list = comma separated list
     |      Requires all given C{ParseExpression}s to be found in the given order.
     |      Expressions may be separated by whitespace.
     |      May be constructed using the C{'+'} operator.
     |      May also be constructed using the C{'-'} operator, which will suppress backtracking.
     |      
     |      Example::
     |          integer = Word(nums)
     |          name_expr = OneOrMore(Word(alphas))
     |      
     |          expr = And([integer("id"),name_expr("name"),integer("age")])
     |          # more easily written as:
     |          expr = integer("id") + name_expr("name") + integer("age")
     |  
     |  fnumber = fnumber
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  fraction = fraction
     |      Requires all given C{ParseExpression}s to be found in the given order.
     |      Expressions may be separated by whitespace.
     |      May be constructed using the C{'+'} operator.
     |      May also be constructed using the C{'-'} operator, which will suppress backtracking.
     |      
     |      Example::
     |          integer = Word(nums)
     |          name_expr = OneOrMore(Word(alphas))
     |      
     |          expr = And([integer("id"),name_expr("name"),integer("age")])
     |          # more easily written as:
     |          expr = integer("id") + name_expr("name") + integer("age")
     |  
     |  hex_integer = hex integer
     |      Token for matching words composed of allowed character sets.
     |      Defined with string containing all allowed initial characters,
     |      an optional string containing allowed body characters (if omitted,
     |      defaults to the initial character set), and an optional minimum,
     |      maximum, and/or exact length.  The default value for C{min} is 1 (a
     |      minimum value < 1 is not valid); the default values for C{max} and C{exact}
     |      are 0, meaning no maximum or exact length restriction. An optional
     |      C{excludeChars} parameter can list characters that might be found in 
     |      the input C{bodyChars} string; useful to define a word of all printables
     |      except for one or two characters, for instance.
     |      
     |      L{srange} is useful for defining custom character set strings for defining 
     |      C{Word} expressions, using range notation from regular expression character sets.
     |      
     |      A common mistake is to use C{Word} to match a specific literal string, as in 
     |      C{Word("Address")}. Remember that C{Word} uses the string argument to define
     |      I{sets} of matchable characters. This expression would match "Add", "AAA",
     |      "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
     |      To match an exact literal string, use L{Literal} or L{Keyword}.
     |      
     |      pyparsing includes helper strings for building Words:
     |       - L{alphas}
     |       - L{nums}
     |       - L{alphanums}
     |       - L{hexnums}
     |       - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     |       - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     |       - L{printables} (any non-whitespace character)
     |      
     |      Example::
     |          # a word composed of digits
     |          integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
     |          
     |          # a word with a leading capital, and zero or more lowercase
     |          capital_word = Word(alphas.upper(), alphas.lower())
     |      
     |          # hostnames are alphanumeric, with leading alpha, and '-'
     |          hostname = Word(alphas, alphanums+'-')
     |          
     |          # roman numeral (not a strict parser, accepts invalid mix of characters)
     |          roman = Word("IVXLCDM")
     |          
     |          # any string of non-whitespace characters, except for ','
     |          csv_value = Word(printables, excludeChars=",")
     |  
     |  identifier = identifier
     |      Token for matching words composed of allowed character sets.
     |      Defined with string containing all allowed initial characters,
     |      an optional string containing allowed body characters (if omitted,
     |      defaults to the initial character set), and an optional minimum,
     |      maximum, and/or exact length.  The default value for C{min} is 1 (a
     |      minimum value < 1 is not valid); the default values for C{max} and C{exact}
     |      are 0, meaning no maximum or exact length restriction. An optional
     |      C{excludeChars} parameter can list characters that might be found in 
     |      the input C{bodyChars} string; useful to define a word of all printables
     |      except for one or two characters, for instance.
     |      
     |      L{srange} is useful for defining custom character set strings for defining 
     |      C{Word} expressions, using range notation from regular expression character sets.
     |      
     |      A common mistake is to use C{Word} to match a specific literal string, as in 
     |      C{Word("Address")}. Remember that C{Word} uses the string argument to define
     |      I{sets} of matchable characters. This expression would match "Add", "AAA",
     |      "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
     |      To match an exact literal string, use L{Literal} or L{Keyword}.
     |      
     |      pyparsing includes helper strings for building Words:
     |       - L{alphas}
     |       - L{nums}
     |       - L{alphanums}
     |       - L{hexnums}
     |       - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     |       - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     |       - L{printables} (any non-whitespace character)
     |      
     |      Example::
     |          # a word composed of digits
     |          integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
     |          
     |          # a word with a leading capital, and zero or more lowercase
     |          capital_word = Word(alphas.upper(), alphas.lower())
     |      
     |          # hostnames are alphanumeric, with leading alpha, and '-'
     |          hostname = Word(alphas, alphanums+'-')
     |          
     |          # roman numeral (not a strict parser, accepts invalid mix of characters)
     |          roman = Word("IVXLCDM")
     |          
     |          # any string of non-whitespace characters, except for ','
     |          csv_value = Word(printables, excludeChars=",")
     |  
     |  integer = integer
     |      Token for matching words composed of allowed character sets.
     |      Defined with string containing all allowed initial characters,
     |      an optional string containing allowed body characters (if omitted,
     |      defaults to the initial character set), and an optional minimum,
     |      maximum, and/or exact length.  The default value for C{min} is 1 (a
     |      minimum value < 1 is not valid); the default values for C{max} and C{exact}
     |      are 0, meaning no maximum or exact length restriction. An optional
     |      C{excludeChars} parameter can list characters that might be found in 
     |      the input C{bodyChars} string; useful to define a word of all printables
     |      except for one or two characters, for instance.
     |      
     |      L{srange} is useful for defining custom character set strings for defining 
     |      C{Word} expressions, using range notation from regular expression character sets.
     |      
     |      A common mistake is to use C{Word} to match a specific literal string, as in 
     |      C{Word("Address")}. Remember that C{Word} uses the string argument to define
     |      I{sets} of matchable characters. This expression would match "Add", "AAA",
     |      "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
     |      To match an exact literal string, use L{Literal} or L{Keyword}.
     |      
     |      pyparsing includes helper strings for building Words:
     |       - L{alphas}
     |       - L{nums}
     |       - L{alphanums}
     |       - L{hexnums}
     |       - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     |       - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     |       - L{printables} (any non-whitespace character)
     |      
     |      Example::
     |          # a word composed of digits
     |          integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
     |          
     |          # a word with a leading capital, and zero or more lowercase
     |          capital_word = Word(alphas.upper(), alphas.lower())
     |      
     |          # hostnames are alphanumeric, with leading alpha, and '-'
     |          hostname = Word(alphas, alphanums+'-')
     |          
     |          # roman numeral (not a strict parser, accepts invalid mix of characters)
     |          roman = Word("IVXLCDM")
     |          
     |          # any string of non-whitespace characters, except for ','
     |          csv_value = Word(printables, excludeChars=",")
     |  
     |  ipv4_address = IPv4 address
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  ipv6_address = IPv6 address
     |      Converter to concatenate all matching tokens to a single string.
     |      By default, the matching patterns must also be contiguous in the input string;
     |      this can be disabled by specifying C{'adjacent=False'} in the constructor.
     |      
     |      Example::
     |          real = Word(nums) + '.' + Word(nums)
     |          print(real.parseString('3.1416')) # -> ['3', '.', '1416']
     |          # will also erroneously match the following
     |          print(real.parseString('3. 1416')) # -> ['3', '.', '1416']
     |      
     |          real = Combine(Word(nums) + '.' + Word(nums))
     |          print(real.parseString('3.1416')) # -> ['3.1416']
     |          # no match when there are internal spaces
     |          print(real.parseString('3. 1416')) # -> Exception: Expected W:(0123...)
     |  
     |  iso8601_date = ISO8601 date
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  iso8601_datetime = ISO8601 datetime
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  mac_address = MAC address
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  mixed_integer = fraction or mixed integer-fraction
     |      Requires that at least one C{ParseExpression} is found.
     |      If two expressions match, the first one listed is the one that will match.
     |      May be constructed using the C{'|'} operator.
     |      
     |      Example::
     |          # construct MatchFirst using '|' operator
     |          
     |          # watch the order of expressions to match
     |          number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
     |          print(number.searchString("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]
     |      
     |          # put more selective expression first
     |          number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
     |          print(number.searchString("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
     |  
     |  number = {real number with scientific notation | real number | signed ...
     |      Requires that at least one C{ParseExpression} is found.
     |      If two expressions match, the first one listed is the one that will match.
     |      May be constructed using the C{'|'} operator.
     |      
     |      Example::
     |          # construct MatchFirst using '|' operator
     |          
     |          # watch the order of expressions to match
     |          number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
     |          print(number.searchString("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]
     |      
     |          # put more selective expression first
     |          number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
     |          print(number.searchString("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
     |  
     |  real = real number
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  sci_real = real number with scientific notation
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  signed_integer = signed integer
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
     |  
     |  uuid = UUID
     |      Token for matching strings that match a given regular expression.
     |      Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
     |      If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
     |      named parse results.
     |      
     |      Example::
     |          realnum = Regex(r"[+-]?\d+\.\d*")
     |          date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
     |          # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
     |          roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")

FUNCTIONS
    col(loc, strg)
        Returns current column within a string, counting newlines as line separators.
        The first column is number 1.
        
        Note: the default parsing behavior is to expand tabs in the input string
        before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
        on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
        consistent view of the parsed string, the parse location, and line and column
        positions within the parsed string.
    
    countedArray(expr, intExpr=None)
        Helper to define a counted list of expressions.
        This helper defines a pattern of the form::
            integer expr expr expr...
        where the leading integer tells how many expr expressions follow.
        The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.
        
        If C{intExpr} is specified, it should be a pyparsing expression that produces an integer value.
        
        Example::
            countedArray(Word(alphas)).parseString('2 ab cd ef')  # -> ['ab', 'cd']
        
            # in this parser, the leading integer value is given in binary,
            # '10' indicating that 2 values are in the array
            binaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2))
            countedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -> ['ab', 'cd']
    
    delimitedList(expr, delim=',', combine=False)
        Helper to define a delimited list of expressions - the delimiter defaults to ','.
        By default, the list elements and delimiters can have intervening whitespace, and
        comments, but this can be overridden by passing C{combine=True} in the constructor.
        If C{combine} is set to C{True}, the matching tokens are returned as a single token
        string, with the delimiters included; otherwise, the matching tokens are returned
        as a list of tokens, with the delimiters suppressed.
        
        Example::
            delimitedList(Word(alphas)).parseString("aa,bb,cc") # -> ['aa', 'bb', 'cc']
            delimitedList(Word(hexnums), delim=':', combine=True).parseString("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
    
    dictOf(key, value)
        Helper to easily and clearly define a dictionary by specifying the respective patterns
        for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens
        in the proper order.  The key pattern can include delimiting markers or punctuation,
        as long as they are suppressed, thereby leaving the significant key text.  The value
        pattern can include named results, so that the C{Dict} results can include named token
        fields.
        
        Example::
            text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
            attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
            print(OneOrMore(attr_expr).parseString(text).dump())
            
            attr_label = label
            attr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)
        
            # similar to Dict, but simpler call format
            result = dictOf(attr_label, attr_value).parseString(text)
            print(result.dump())
            print(result['shape'])
            print(result.shape)  # object attribute access works too
            print(result.asDict())
        prints::
            [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
            - color: light blue
            - posn: upper left
            - shape: SQUARE
            - texture: burlap
            SQUARE
            SQUARE
            {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
    
    downcaseTokens lambda s, l, t
    
    indentedBlock(blockStatementExpr, indentStack, indent=True)
        Helper method for defining space-delimited indentation blocks, such as
        those used to define block statements in Python source code.
        
        Parameters:
         - blockStatementExpr - expression defining syntax of statement that
                is repeated within the indented block
         - indentStack - list created by caller to manage indentation stack
                (multiple statementWithIndentedBlock expressions within a single grammar
                should share a common indentStack)
         - indent - boolean indicating whether block must be indented beyond the
                the current level; set to False for block of left-most statements
                (default=C{True})
        
        A valid block must contain at least one C{blockStatement}.
        
        Example::
            data = '''
            def A(z):
              A1
              B = 100
              G = A2
              A2
              A3
            B
            def BB(a,b,c):
              BB1
              def BBA():
                bba1
                bba2
                bba3
            C
            D
            def spam(x,y):
                 def eggs(z):
                     pass
            '''
        
        
            indentStack = [1]
            stmt = Forward()
        
            identifier = Word(alphas, alphanums)
            funcDecl = ("def" + identifier + Group( "(" + Optional( delimitedList(identifier) ) + ")" ) + ":")
            func_body = indentedBlock(stmt, indentStack)
            funcDef = Group( funcDecl + func_body )
        
            rvalue = Forward()
            funcCall = Group(identifier + "(" + Optional(delimitedList(rvalue)) + ")")
            rvalue << (funcCall | identifier | Word(nums))
            assignment = Group(identifier + "=" + rvalue)
            stmt << ( funcDef | assignment | identifier )
        
            module_body = OneOrMore(stmt)
        
            parseTree = module_body.parseString(data)
            parseTree.pprint()
        prints::
            [['def',
              'A',
              ['(', 'z', ')'],
              ':',
              [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
             'B',
             ['def',
              'BB',
              ['(', 'a', 'b', 'c', ')'],
              ':',
              [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
             'C',
             'D',
             ['def',
              'spam',
              ['(', 'x', 'y', ')'],
              ':',
              [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]
    
    infixNotation(baseExpr, opList, lpar=Suppress:("("), rpar=Suppress:(")"))
        Helper method for constructing grammars of expressions made up of
        operators working in a precedence hierarchy.  Operators may be unary or
        binary, left- or right-associative.  Parse actions can also be attached
        to operator expressions. The generated parser will also recognize the use 
        of parentheses to override operator precedences (see example below).
        
        Note: if you define a deep operator list, you may see performance issues
        when using infixNotation. See L{ParserElement.enablePackrat} for a
        mechanism to potentially improve your parser performance.
        
        Parameters:
         - baseExpr - expression representing the most basic element for the nested
         - opList - list of tuples, one for each operator precedence level in the
          expression grammar; each tuple is of the form
          (opExpr, numTerms, rightLeftAssoc, parseAction), where:
           - opExpr is the pyparsing expression for the operator;
              may also be a string, which will be converted to a Literal;
              if numTerms is 3, opExpr is a tuple of two expressions, for the
              two operators separating the 3 terms
           - numTerms is the number of terms for this operator (must
              be 1, 2, or 3)
           - rightLeftAssoc is the indicator whether the operator is
              right or left associative, using the pyparsing-defined
              constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
           - parseAction is the parse action to be associated with
              expressions matching this operator expression (the
              parse action tuple member may be omitted); if the parse action
              is passed a tuple or list of functions, this is equivalent to
              calling C{setParseAction(*fn)} (L{ParserElement.setParseAction})
         - lpar - expression for matching left-parentheses (default=C{Suppress('(')})
         - rpar - expression for matching right-parentheses (default=C{Suppress(')')})
        
        Example::
            # simple example of four-function arithmetic with ints and variable names
            integer = pyparsing_common.signed_integer
            varname = pyparsing_common.identifier 
            
            arith_expr = infixNotation(integer | varname,
                [
                ('-', 1, opAssoc.RIGHT),
                (oneOf('* /'), 2, opAssoc.LEFT),
                (oneOf('+ -'), 2, opAssoc.LEFT),
                ])
            
            arith_expr.runTests('''
                5+3*6
                (5+3)*6
                -2--11
                ''', fullDump=False)
        prints::
            5+3*6
            [[5, '+', [3, '*', 6]]]
        
            (5+3)*6
            [[[5, '+', 3], '*', 6]]
        
            -2--11
            [[['-', 2], '-', ['-', 11]]]
    
    line(loc, strg)
        Returns the line of text containing loc within a string, counting newlines as line separators.
    
    lineno(loc, strg)
        Returns current line number within a string, counting newlines as line separators.
        The first line is number 1.
        
        Note: the default parsing behavior is to expand tabs in the input string
        before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
        on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
        consistent view of the parsed string, the parse location, and line and column
        positions within the parsed string.
    
    locatedExpr(expr)
        Helper to decorate a returned token with its starting and ending locations in the input string.
        This helper adds the following results names:
         - locn_start = location where matched expression begins
         - locn_end = location where matched expression ends
         - value = the actual parsed results
        
        Be careful if the input text contains C{<TAB>} characters, you may want to call
        C{L{ParserElement.parseWithTabs}}
        
        Example::
            wd = Word(alphas)
            for match in locatedExpr(wd).searchString("ljsdf123lksdjjf123lkkjj1222"):
                print(match)
        prints::
            [[0, 'ljsdf', 5]]
            [[8, 'lksdjjf', 15]]
            [[18, 'lkkjj', 23]]
    
    makeHTMLTags(tagStr)
        Helper to construct opening and closing tag expressions for HTML, given a tag name. Matches
        tags in either upper or lower case, attributes with namespaces and with quoted or unquoted values.
        
        Example::
            text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
            # makeHTMLTags returns pyparsing expressions for the opening and closing tags as a 2-tuple
            a,a_end = makeHTMLTags("A")
            link_expr = a + SkipTo(a_end)("link_text") + a_end
            
            for link in link_expr.searchString(text):
                # attributes in the <A> tag (like "href" shown here) are also accessible as named results
                print(link.link_text, '->', link.href)
        prints::
            pyparsing -> http://pyparsing.wikispaces.com
    
    makeXMLTags(tagStr)
        Helper to construct opening and closing tag expressions for XML, given a tag name. Matches
        tags only in the given upper/lower case.
        
        Example: similar to L{makeHTMLTags}
    
    matchOnlyAtCol(n)
        Helper method for defining parse actions that require matching at a specific
        column in the input text.
    
    matchPreviousExpr(expr)
        Helper to define an expression that is indirectly defined from
        the tokens matched in a previous expression, that is, it looks
        for a 'repeat' of a previous expression.  For example::
            first = Word(nums)
            second = matchPreviousExpr(first)
            matchExpr = first + ":" + second
        will match C{"1:1"}, but not C{"1:2"}.  Because this matches by
        expressions, will I{not} match the leading C{"1:1"} in C{"1:10"};
        the expressions are evaluated first, and then compared, so
        C{"1"} is compared with C{"10"}.
        Do I{not} use with packrat parsing enabled.
    
    matchPreviousLiteral(expr)
        Helper to define an expression that is indirectly defined from
        the tokens matched in a previous expression, that is, it looks
        for a 'repeat' of a previous expression.  For example::
            first = Word(nums)
            second = matchPreviousLiteral(first)
            matchExpr = first + ":" + second
        will match C{"1:1"}, but not C{"1:2"}.  Because this matches a
        previous literal, will also match the leading C{"1:1"} in C{"1:10"}.
        If this is not desired, use C{matchPreviousExpr}.
        Do I{not} use with packrat parsing enabled.
    
    nestedExpr(opener='(', closer=')', content=None, ignoreExpr=quotedString using single or double quotes)
        Helper method for defining nested lists enclosed in opening and closing
        delimiters ("(" and ")" are the default).
        
        Parameters:
         - opener - opening character for a nested list (default=C{"("}); can also be a pyparsing expression
         - closer - closing character for a nested list (default=C{")"}); can also be a pyparsing expression
         - content - expression for items within the nested lists (default=C{None})
         - ignoreExpr - expression for ignoring opening and closing delimiters (default=C{quotedString})
        
        If an expression is not provided for the content argument, the nested
        expression will capture all whitespace-delimited content between delimiters
        as a list of separate values.
        
        Use the C{ignoreExpr} argument to define expressions that may contain
        opening or closing characters that should not be treated as opening
        or closing characters for nesting, such as quotedString or a comment
        expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.
        The default is L{quotedString}, but if no expressions are to be ignored,
        then pass C{None} for this argument.
        
        Example::
            data_type = oneOf("void int short long char float double")
            decl_data_type = Combine(data_type + Optional(Word('*')))
            ident = Word(alphas+'_', alphanums+'_')
            number = pyparsing_common.number
            arg = Group(decl_data_type + ident)
            LPAR,RPAR = map(Suppress, "()")
        
            code_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment))
        
            c_function = (decl_data_type("type") 
                          + ident("name")
                          + LPAR + Optional(delimitedList(arg), [])("args") + RPAR 
                          + code_body("body"))
            c_function.ignore(cStyleComment)
            
            source_code = '''
                int is_odd(int x) { 
                    return (x%2); 
                }
                    
                int dec_to_hex(char hchar) { 
                    if (hchar >= '0' && hchar <= '9') { 
                        return (ord(hchar)-ord('0')); 
                    } else { 
                        return (10+ord(hchar)-ord('A'));
                    } 
                }
            '''
            for func in c_function.searchString(source_code):
                print("%(name)s (%(type)s) args: %(args)s" % func)
        
        prints::
            is_odd (int) args: [['int', 'x']]
            dec_to_hex (int) args: [['char', 'hchar']]
    
    nullDebugAction(*args)
        'Do-nothing' debug action, to suppress debugging output during parsing.
    
    oneOf(strs, caseless=False, useRegex=True)
        Helper to quickly define a set of alternative Literals, and makes sure to do
        longest-first testing when there is a conflict, regardless of the input order,
        but returns a C{L{MatchFirst}} for best performance.
        
        Parameters:
         - strs - a string of space-delimited literals, or a collection of string literals
         - caseless - (default=C{False}) - treat all literals as caseless
         - useRegex - (default=C{True}) - as an optimization, will generate a Regex
              object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or
              if creating a C{Regex} raises an exception)
        
        Example::
            comp_oper = oneOf("< = > <= >= !=")
            var = Word(alphas)
            number = Word(nums)
            term = var | number
            comparison_expr = term + comp_oper + term
            print(comparison_expr.searchString("B = 12  AA=23 B<=AA AA>12"))
        prints::
            [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
    
    operatorPrecedence = infixNotation(baseExpr, opList, lpar=Suppress:("("), rpar=Suppress:(")"))
        Helper method for constructing grammars of expressions made up of
        operators working in a precedence hierarchy.  Operators may be unary or
        binary, left- or right-associative.  Parse actions can also be attached
        to operator expressions. The generated parser will also recognize the use 
        of parentheses to override operator precedences (see example below).
        
        Note: if you define a deep operator list, you may see performance issues
        when using infixNotation. See L{ParserElement.enablePackrat} for a
        mechanism to potentially improve your parser performance.
        
        Parameters:
         - baseExpr - expression representing the most basic element for the nested
         - opList - list of tuples, one for each operator precedence level in the
          expression grammar; each tuple is of the form
          (opExpr, numTerms, rightLeftAssoc, parseAction), where:
           - opExpr is the pyparsing expression for the operator;
              may also be a string, which will be converted to a Literal;
              if numTerms is 3, opExpr is a tuple of two expressions, for the
              two operators separating the 3 terms
           - numTerms is the number of terms for this operator (must
              be 1, 2, or 3)
           - rightLeftAssoc is the indicator whether the operator is
              right or left associative, using the pyparsing-defined
              constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
           - parseAction is the parse action to be associated with
              expressions matching this operator expression (the
              parse action tuple member may be omitted); if the parse action
              is passed a tuple or list of functions, this is equivalent to
              calling C{setParseAction(*fn)} (L{ParserElement.setParseAction})
         - lpar - expression for matching left-parentheses (default=C{Suppress('(')})
         - rpar - expression for matching right-parentheses (default=C{Suppress(')')})
        
        Example::
            # simple example of four-function arithmetic with ints and variable names
            integer = pyparsing_common.signed_integer
            varname = pyparsing_common.identifier 
            
            arith_expr = infixNotation(integer | varname,
                [
                ('-', 1, opAssoc.RIGHT),
                (oneOf('* /'), 2, opAssoc.LEFT),
                (oneOf('+ -'), 2, opAssoc.LEFT),
                ])
            
            arith_expr.runTests('''
                5+3*6
                (5+3)*6
                -2--11
                ''', fullDump=False)
        prints::
            5+3*6
            [[5, '+', [3, '*', 6]]]
        
            (5+3)*6
            [[[5, '+', 3], '*', 6]]
        
            -2--11
            [[['-', 2], '-', ['-', 11]]]
    
    originalTextFor(expr, asString=True)
        Helper to return the original, untokenized text for a given expression.  Useful to
        restore the parsed fields of an HTML start tag into the raw tag text itself, or to
        revert separate tokens with intervening whitespace back to the original matching
        input text. By default, returns astring containing the original parsed text.  
           
        If the optional C{asString} argument is passed as C{False}, then the return value is a 
        C{L{ParseResults}} containing any results names that were originally matched, and a 
        single token containing the original matched text from the input string.  So if 
        the expression passed to C{L{originalTextFor}} contains expressions with defined
        results names, you must set C{asString} to C{False} if you want to preserve those
        results name values.
        
        Example::
            src = "this is test <b> bold <i>text</i> </b> normal text "
            for tag in ("b","i"):
                opener,closer = makeHTMLTags(tag)
                patt = originalTextFor(opener + SkipTo(closer) + closer)
                print(patt.searchString(src)[0])
        prints::
            ['<b> bold <i>text</i> </b>']
            ['<i>text</i>']
    
    removeQuotes(s, l, t)
        Helper parse action for removing quotation marks from parsed quoted strings.
        
        Example::
            # by default, quotation marks are included in parsed results
            quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]
        
            # use removeQuotes to strip quotation marks from parsed results
            quotedString.setParseAction(removeQuotes)
            quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
    
    replaceHTMLEntity(t)
        Helper parser action to replace common HTML entities with their special characters
    
    replaceWith(replStr)
        Helper method for common parse actions that simply return a literal value.  Especially
        useful when used with C{L{transformString<ParserElement.transformString>}()}.
        
        Example::
            num = Word(nums).setParseAction(lambda toks: int(toks[0]))
            na = oneOf("N/A NA").setParseAction(replaceWith(math.nan))
            term = na | num
            
            OneOrMore(term).parseString("324 234 N/A 234") # -> [324, 234, nan, 234]
    
    srange(s)
        Helper to easily define string ranges for use in Word construction.  Borrows
        syntax from regexp '[]' string range definitions::
            srange("[0-9]")   -> "0123456789"
            srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
            srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"
        The input string must be enclosed in []'s, and the returned string is the expanded
        character set joined into a single string.
        The values enclosed in the []'s may be:
         - a single character
         - an escaped character with a leading backslash (such as C{\-} or C{\]})
         - an escaped hex character with a leading C{'\x'} (C{\x21}, which is a C{'!'} character) 
             (C{\0x##} is also supported for backwards compatibility) 
         - an escaped octal character with a leading C{'\0'} (C{\041}, which is a C{'!'} character)
         - a range of any of the above, separated by a dash (C{'a-z'}, etc.)
         - any combination of the above (C{'aeiouy'}, C{'a-zA-Z0-9_$'}, etc.)
    
    tokenMap(func, *args)
        Helper to define a parse action by mapping a function to all elements of a ParseResults list.If any additional 
        args are passed, they are forwarded to the given function as additional arguments after
        the token, as in C{hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))}, which will convert the
        parsed data to an integer using base 16.
        
        Example (compare the last to example in L{ParserElement.transformString}::
            hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))
            hex_ints.runTests('''
                00 11 22 aa FF 0a 0d 1a
                ''')
            
            upperword = Word(alphas).setParseAction(tokenMap(str.upper))
            OneOrMore(upperword).runTests('''
                my kingdom for a horse
                ''')
        
            wd = Word(alphas).setParseAction(tokenMap(str.title))
            OneOrMore(wd).setParseAction(' '.join).runTests('''
                now is the winter of our discontent made glorious summer by this sun of york
                ''')
        prints::
            00 11 22 aa FF 0a 0d 1a
            [0, 17, 34, 170, 255, 10, 13, 26]
        
            my kingdom for a horse
            ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']
        
            now is the winter of our discontent made glorious summer by this sun of york
            ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
    
    traceParseAction(f)
        Decorator for debugging parse actions. 
        
        When the parse action is called, this decorator will print C{">> entering I{method-name}(line:I{current_source_line}, I{parse_location}, I{matched_tokens})".}
        When the parse action completes, the decorator will print C{"<<"} followed by the returned value, or any exception that the parse action raised.
        
        Example::
            wd = Word(alphas)
        
            @traceParseAction
            def remove_duplicate_chars(tokens):
                return ''.join(sorted(set(''.join(tokens)))
        
            wds = OneOrMore(wd).setParseAction(remove_duplicate_chars)
            print(wds.parseString("slkdjs sld sldd sdlf sdljf"))
        prints::
            >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
            <<leaving remove_duplicate_chars (ret: 'dfjkls')
            ['dfjkls']
    
    ungroup(expr)
        Helper to undo pyparsing's default grouping of And expressions, even
        if all but one are non-empty.
    
    upcaseTokens lambda s, l, t
    
    withAttribute(*args, **attrDict)
        Helper to create a validating parse action to be used with start tags created
        with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag
        with a required attribute value, to avoid false matches on common tags such as
        C{<TD>} or C{<DIV>}.
        
        Call C{withAttribute} with a series of attribute names and values. Specify the list
        of filter attributes names and values as:
         - keyword arguments, as in C{(align="right")}, or
         - as an explicit dict with C{**} operator, when an attribute name is also a Python
              reserved word, as in C{**{"class":"Customer", "align":"right"}}
         - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") )
        For attribute names with a namespace prefix, you must use the second form.  Attribute
        names are matched insensitive to upper/lower case.
           
        If just testing for C{class} (with or without a namespace), use C{L{withClass}}.
        
        To verify that the attribute exists, but without specifying a value, pass
        C{withAttribute.ANY_VALUE} as the value.
        
        Example::
            html = '''
                <div>
                Some text
                <div type="grid">1 4 0 1 0</div>
                <div type="graph">1,3 2,3 1,1</div>
                <div>this has no type</div>
                </div>
                    
            '''
            div,div_end = makeHTMLTags("div")
        
            # only match div tag having a type attribute with value "grid"
            div_grid = div().setParseAction(withAttribute(type="grid"))
            grid_expr = div_grid + SkipTo(div | div_end)("body")
            for grid_header in grid_expr.searchString(html):
                print(grid_header.body)
            
            # construct a match with any div tag having a type attribute, regardless of the value
            div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))
            div_expr = div_any_type + SkipTo(div | div_end)("body")
            for div_header in div_expr.searchString(html):
                print(div_header.body)
        prints::
            1 4 0 1 0
        
            1 4 0 1 0
            1,3 2,3 1,1
    
    withClass(classname, namespace='')
        Simplified version of C{L{withAttribute}} when matching on a div class - made
        difficult because C{class} is a reserved word in Python.
        
        Example::
            html = '''
                <div>
                Some text
                <div class="grid">1 4 0 1 0</div>
                <div class="graph">1,3 2,3 1,1</div>
                <div>this &lt;div&gt; has no class</div>
                </div>
                    
            '''
            div,div_end = makeHTMLTags("div")
            div_grid = div().setParseAction(withClass("grid"))
            
            grid_expr = div_grid + SkipTo(div | div_end)("body")
            for grid_header in grid_expr.searchString(html):
                print(grid_header.body)
            
            div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))
            div_expr = div_any_type + SkipTo(div | div_end)("body")
            for div_header in div_expr.searchString(html):
                print(div_header.body)
        prints::
            1 4 0 1 0
        
            1 4 0 1 0
            1,3 2,3 1,1

DATA
    __all__ = ['And', 'CaselessKeyword', 'CaselessLiteral', 'CharsNotIn', ...
    __versionTime__ = '06 Mar 2017 02:06 UTC'
    alphanums = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234...
    alphas = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    alphas8bit = '\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf8\xf9...
    anyCloseTag = </any tag>
    anyOpenTag = <any tag>
    cStyleComment = C style comment
    commaSeparatedList = commaSeparatedList
    commonHTMLEntity = common HTML entity
    cppStyleComment = C++ style comment
    dblQuotedString = string enclosed in double quotes
    dblSlashComment = // comment
    empty = empty
    hexnums = '0123456789ABCDEFabcdef'
    htmlComment = HTML comment
    javaStyleComment = C++ style comment
    lineEnd = lineEnd
    lineStart = lineStart
    nums = '0123456789'
    opAssoc = <pyparsing._Constants object>
    printables = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRST...
    punc8bit = '\xa1\xa2\xa3\xa5\xa8\xaa\xad\xaf\xb2\xb3\xb4\xb8\xb9\xba\xbc\xbd\xbe\xbf\xd7\xf7'
    pythonStyleComment = Python style comment
    quotedString = quotedString using single or double quotes
    restOfLine = rest of line
    sglQuotedString = string enclosed in single quotes
    stringEnd = stringEnd
    stringStart = stringStart
    unicodeString = unicode string literal

VERSION
    2.2.0

AUTHOR
    Paul McGuire <ptmcg@users.sourceforge.net>

FILE
    c:\programdata\anaconda3\lib\site-packages\pyparsing.py


